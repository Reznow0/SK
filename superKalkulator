// SuperKalkulator.cpp : Ten plik zawiera funkcję „main”. W nim rozpoczyna się i kończy wykonywanie programu.
//

#include "pch.h"
#include <iostream>
#include <stdint.h>//uint32_t

using namespace std;

#define M_PI 3.141592653589793

void WczytajArgumentyDouble(int liczbaArgumentow, double *wskaznikDoTablicy) {

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cin >> wskaznikDoTablicy[i];
	}
}

void WczytajArgumentyInt(int liczbaArgumentow, int *wskaznikDoTablicy) {

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cin >> wskaznikDoTablicy[i];
	}
}

void WczytajArgumentyUint(int liczbaArgumentow, uint32_t *wskaznikDoTablicy) {

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cin >> wskaznikDoTablicy[i];
	}
}


void ZamienMiejscami(double &argument1, double &argument2) {

	double *x = &argument1;
	double *y = &argument2;


	if (*x != *y) { // zamiana bez użycia 3-ciej zmiennej
		*x += *y;
		*y = *x - *y;
		*x -= *y;
	}
}

double Podloga(double x) {
	if (x >= 0) {
		return (int)x;
	}
	else {
		if ((int)x != x) {
			return (int)(x - 1);
		}
		else return x;
	}
}
double Sufit(double x) {
	if (x >= 0) {
		return (int)(x + 1);
	}
	else {
		if ((int)x != x) {
			return (int)x;
		}
		else return x;
	}
}

//znajdź pozycje najmniejszej liczby
int f0(int liczbaArgumentow, double *wskaznikDoTablicy) {

	double najmniejszaWartosc = 2147483647; //wartość maksymalna dla int'a

	if (wskaznikDoTablicy == NULL) {
		int *tablicaArgumentow = new int[liczbaArgumentow];
		WczytajArgumentyInt(liczbaArgumentow, tablicaArgumentow);

		int pozycja = 0;

		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (tablicaArgumentow[i] < najmniejszaWartosc) {
				najmniejszaWartosc = tablicaArgumentow[i];
				pozycja = i;
			}
		}
		//teraz znajdz możliwe wystąpienia kilku najmniejszych takich samych liczb
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (tablicaArgumentow[i] == tablicaArgumentow[pozycja])
				cout << i + 1 << " "; //+ 1, bo tablica zaczyna sie od 0
		}
		cout << endl;
		delete[] tablicaArgumentow;
		return pozycja;
	}
	else {//jeśli funkcja jakaś podała już istniejącą tablicę
	
		int pozycja = 0;

		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (wskaznikDoTablicy[i] < najmniejszaWartosc) {
				najmniejszaWartosc = wskaznikDoTablicy[i];
				pozycja = i;
			}
		}
		return pozycja;
	}
}

//posortuj tablice malejąco
void f1(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];

	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);
	int pozycja = 0;

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		pozycja = f0(liczbaArgumentow - i, tablicaArgumentow);//podaj do f0 liczbaArgumentow - i, a na koncowkach 'tablicaArgumentow' dodawaj najmniejsze liczby

		ZamienMiejscami(tablicaArgumentow[liczbaArgumentow - i - 1], tablicaArgumentow[pozycja]);
	}

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;

}

//znajdz długość wektora
double f2(int liczbaArgumentow, double *wskaznikDoTablicy) {


	if (wskaznikDoTablicy == NULL) {
		double *tablicaArgumentow = new double[liczbaArgumentow];

		WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);


		double suma = 0;
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			suma += tablicaArgumentow[i] * tablicaArgumentow[i];
		}

		delete[] tablicaArgumentow;

		cout << Podloga(sqrt(suma)) << endl;
		return 0;
	}

	else {//jeśli funkcja jakaś podała już istniejącą tablicę
		double suma = 0;
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			suma += wskaznikDoTablicy[i] * wskaznikDoTablicy[i];
		}

		return sqrt(suma);
	}
}

//znajdz odchylenie standardowe
void f3(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	double sredniaLiczb = 0;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		sredniaLiczb += tablicaArgumentow[i];
	}
	sredniaLiczb = sredniaLiczb / liczbaArgumentow;

	//cout << "SREDNIA LICZB " << sredniaLiczb << endl;

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		tablicaArgumentow[i] -= sredniaLiczb;
		//cout << tablicaArgumentow[i] << " ";
	}
	double odchylenie = f2(liczbaArgumentow, tablicaArgumentow) / sqrt((double)liczbaArgumentow - 1);

	cout << Podloga(odchylenie)<< endl;

	delete[] tablicaArgumentow;
}

//odwróć tablice w miejscu
void f4(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	for (int i = 0; i < liczbaArgumentow / 2; i++)
	{
		tablicaArgumentow[liczbaArgumentow - i - 1] += tablicaArgumentow[i];
		tablicaArgumentow[i] = tablicaArgumentow[liczbaArgumentow - i - 1] - tablicaArgumentow[i];
		tablicaArgumentow[liczbaArgumentow - i - 1] -= tablicaArgumentow[i];
	}
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;
}

//sprawdz czy liczby sa pierwsze
void f5(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	bool czyLiczbaJestPierwsza;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		czyLiczbaJestPierwsza = true;
		for (int j = 2; j <= Podloga(sqrt(tablicaArgumentow[i])); j++)
		{
			if ((int)Podloga(tablicaArgumentow[i]) % (j) == 0) {
				czyLiczbaJestPierwsza = false;
				break;
			}
		}
		//cout << czyLiczbaJestPierwsza;
		if (czyLiczbaJestPierwsza) {
			tablicaArgumentow[i] = 1;
		}
		else {
			tablicaArgumentow[i] = 0;
		}

		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;
}

void PosortujPunktyZadanie6(int liczbaArgumentow, double *tablicaArgumentow, double srodekX, double srodekY) {

	double *tablicaKatow = new double[liczbaArgumentow];

	//oblicz tangensa dla kazdego punktu xy
	for (int i = 0; i < liczbaArgumentow - 1; i += 2)//liczymy clockwise > v < ^
	{
		double deltaX = tablicaArgumentow[i] - srodekX;
		double deltaY = tablicaArgumentow[i + 1] - srodekY;

		tablicaKatow[i / 2] = (atan2(deltaY, deltaX) * 180 / M_PI); // tangens, konwersja na stopnie, tablica ta posiada polowe wielkosci 'tablicaArgumentow'
	}

	//posortować teraz wg kątów malejąco

	for (int i = 0; i < liczbaArgumentow; i += 2)
	{
		double najmniejszaWartosc = 2147483647; //wartość maksymalna dla int'a
		int pozycja = 0;

		for (int j = 0; j < (liczbaArgumentow - i) / 2; j++) // i/2 bo tablicaKatow jest 2 razy mniejsza
		{
			if (tablicaKatow[j] < najmniejszaWartosc) {
				najmniejszaWartosc = tablicaKatow[j];
				pozycja = j;
			}
		}

		ZamienMiejscami(tablicaKatow[((liczbaArgumentow - i) / 2) - 1], tablicaKatow[pozycja]);//kąty

		ZamienMiejscami(tablicaArgumentow[liczbaArgumentow - 2 - i], tablicaArgumentow[pozycja * 2]);//wartosci x punktów
		ZamienMiejscami(tablicaArgumentow[liczbaArgumentow - 1 - i], tablicaArgumentow[pozycja * 2 + 1]);//wartosci y punktów
	}
}

struct punkt{
	double x;
	double y;
} Punkt;

//pole wielokąta wypukłego
void f6(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	//oblicz punkt leżący wewnatrz wielokąta
	double srodekX = 0, srodekY = 0;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		if (i % 2 == 0) {
			srodekX += tablicaArgumentow[i];
		}
		else {
			srodekY += tablicaArgumentow[i];
		}
	}

	srodekX = srodekX / (liczbaArgumentow / 2);
	srodekY = srodekY / (liczbaArgumentow / 2);

	PosortujPunktyZadanie6(liczbaArgumentow, tablicaArgumentow, srodekX, srodekY);

	//policz pole tego wielokata
	int suma = 0;

	for (int i = 0; i < liczbaArgumentow - 3; i+=2)
	{
		suma += (tablicaArgumentow[i] * tablicaArgumentow[i + 3] - tablicaArgumentow[i + 1] * tablicaArgumentow[i + 2]);
	}

	suma += (tablicaArgumentow[liczbaArgumentow - 2] * tablicaArgumentow[1] - tablicaArgumentow[liczbaArgumentow - 1] * tablicaArgumentow[0]); //ostatni element sumy
	cout << abs(suma / 2) << endl;

	delete[] tablicaArgumentow;
}

//równanie kwadratowe i sześcienne
void f7(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	//równanie kwadratowe
	if (tablicaArgumentow[0] == 0) {
		double a = tablicaArgumentow[1];
		double b = tablicaArgumentow[2];
		double c = tablicaArgumentow[3];

		double delta = b * b - 4 * a*c;

		if (delta >= 0) {
			double x1 = (-b - sqrt(delta)) / (2 * a);
			double x2 = (-b + sqrt(delta)) / (2 * a);

			if (x1 == x2) {
				cout << Podloga(x1) << endl;
			}
			else {
				if (x1 < x2) {
					cout << Podloga(x1) << " " << Podloga(x2) << endl;
				}
				else {
					cout << Podloga(x2) << " " << Podloga(x1) << endl;
				}
			}
		}
	}
	else {
		//równanie sześcienne
		double a = tablicaArgumentow[1]; // od drugiego elementu jest a
		double b = tablicaArgumentow[2];
		double c = tablicaArgumentow[3];

		double p = b - a * a / 3;
		double q = 2 * a*a*a / 27 - a * b / 3 + c;
		
		double delta = q * q / 4 + p * p*p / 27;

		if (Sufit(delta) > 0) {//jest tylko jedno rozwiązanie
			
			double pomocnicza1 = -q / 2 + sqrt(delta);
			double pomocnicza2 = -q / 2 - sqrt(delta);
			double x = 0;

			if (pomocnicza1 < 0) {
				x += -pow(-pomocnicza1, 1.0 / 3.0);
			}
			else {
				x += pow(pomocnicza1, 1.0 / 3.0);
			}

			if (pomocnicza2 < 0) {
				x += -pow(-pomocnicza2, 1.0 / 3.0);
			}
			else {
				x += pow(pomocnicza2, 1.0 / 3.0);
			}

			x -= a / 3.0;
			cout << Podloga(x) << endl;
		}

		else if (Sufit(delta) == 0) { // dwa rozwiązania		

			double x1 = 0, x2 = 0;
			if (q < 0) {
				x1 = -2 * (-pow(-q / 2.0, 1.0 / 3.0)) - a / 3.0;
				x2 = (-pow(-q / 2.0, 1.0 / 3.0)) - a / 3.0;
			}
			else {
				x1 = -2 * pow(q / 2.0, 1.0 / 3.0) - a / 3.0;
				x2 = pow(q / 2.0, 1.0 / 3.0) - a / 3.0;
			}

			cout << Podloga(x1) << " " << Podloga(x2) << endl;
		}
		else { // trzy rozwiązania
			double x1 = 2 / sqrt(3.0)*sqrt(-p)*sin(1.0 / 3.0 * asin((3.0 * sqrt(3.0)*q) / (2.0 * sqrt(-p)*sqrt(-p)*sqrt(-p)))) - a/3.0;
			double x2 = 2 / sqrt(3.0)*sqrt(-p)*sin(1.0 / 3.0 * asin((3.0 * sqrt(3.0)*q) / (2.0 * sqrt(-p)*sqrt(-p)*sqrt(-p))) + M_PI / 3.0) - a / 3.0;
			double x3 = 2 / sqrt(3.0)*sqrt(-p)*sin(1.0 / 3.0 * acos((3.0 * sqrt(3.0)*q) / (2.0 * sqrt(-p)*sqrt(-p)*sqrt(-p))) + M_PI / 6.0) - a / 3.0;

			cout << Podloga(x1) << " " << Podloga(x2) << " " << Podloga(x3) << endl;
		}

	}

	delete[] tablicaArgumentow;
}

//oblicz wyrażenie dla zadanego n
void f8(int liczbaArgumentow) {
	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	long long int wynik = 0;
	for (int i = 1; i <= tablicaArgumentow[0]; i++)
	{
		wynik += i * (i + 1)*(i + 1);
	}
	cout << fixed << wynik<< endl;
	delete[] tablicaArgumentow;
}

// zlicz liczbę bitów
void f9(int liczbaArgumentow) {
	uint32_t *tablicaArgumentow = new uint32_t[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		uint32_t liczbaBitow = tablicaArgumentow[i];

		liczbaBitow = liczbaBitow - ((liczbaBitow >> 1) & 0x55555555);
		liczbaBitow = (liczbaBitow & 0x33333333) + ((liczbaBitow >> 2) & 0x33333333);
		liczbaBitow = (((liczbaBitow + (liczbaBitow >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;

		cout << liczbaBitow << " ";
	}
	cout << endl;
}

int main() {
	int subprogram, liczbaArgumentow;

	while (cin >> subprogram >> liczbaArgumentow) {
		switch (subprogram) {
		case 0:
			f0(liczbaArgumentow, NULL);
			break;
		case 1:
			f1(liczbaArgumentow);
			break;
		case 2:
			f2(liczbaArgumentow, NULL);
			break;
		case 3:
			f3(liczbaArgumentow);
			break;
		case 4:
			f4(liczbaArgumentow);
			break;
		case 5:
			f5(liczbaArgumentow);
			break;
		case 6:
			f6(liczbaArgumentow);
			break;
		case 7:
			f7(liczbaArgumentow);
			break;
		case 8:
			f8(liczbaArgumentow);
			break;
		case 9:
			f9(liczbaArgumentow);
			break;
		}
	};
	return 0;
}
// Uruchomienie programu: Ctrl + F5 lub menu Debugowanie > Uruchom bez debugowania
// Debugowanie programu: F5 lub menu Debugowanie > Rozpocznij debugowanie

// Porady dotyczące rozpoczynania pracy:
//   1. Użyj okna Eksploratora rozwiązań, aby dodać pliki i zarządzać nimi
//   2. Użyj okna programu Team Explorer, aby nawiązać połączenie z kontrolą źródła
//   3. Użyj okna Dane wyjściowe, aby sprawdzić dane wyjściowe kompilacji i inne komunikaty
//   4. Użyj okna Lista błędów, aby zobaczyć błędy
//   5. Wybierz pozycję Projekt > Dodaj nowy element, aby utworzyć nowe pliki kodu, lub wybierz pozycję Projekt > Dodaj istniejący element, aby dodać istniejące pliku kodu do projektu
//   6. Aby w przyszłości ponownie otworzyć ten projekt, przejdź do pozycji Plik > Otwórz > Projekt i wybierz plik sln
