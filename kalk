#include <iostream>
#include <stdint.h>

using namespace std;

#define M_PI 3.141592653589793

void WczytajArgumentyDoTablicy(int liczbaArgumentow, double *wskaznikDoTablicy) {

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cin >> wskaznikDoTablicy[i];
	}
}

void ZamienMiejscami(double &argument1, double &argument2) {

	double *x = &argument1;
	double *y = &argument2;


	if (*x != *y) { // zamiana bez u|ycia 3-ciej zmiennej
		*x += *y;
		*y = *x - *y;
		*x -= *y;
	}
}

double Podloga(double x) {
	if (x >= 0) {
		return (int)x;
	}
	else {
		if ((int)x != x) {
			return (int)(x - 1);
		}
		else return x;
	}
}
double Sufit(double x) {
	if (x >= 0) {
		return (int)(x + 1);
	}
	else {
		if ((int)x != x) {
			return (int)x;
		}
		else return x;
	}
}

//znajdz pozycje najmniejszej liczby
int f0(int liczbaArgumentow, double *wskaznikDoTablicy) {

	if (wskaznikDoTablicy == NULL) {
		double *tablicaArgumentow = new double[liczbaArgumentow];
		WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);


		int najmniejszaWartosc = 2147483647; //warto[ maksymalna dla int'a
		int pozycja = 0;

		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (tablicaArgumentow[i] < najmniejszaWartosc) {
				najmniejszaWartosc = tablicaArgumentow[i];
				pozycja = i;
			}
		}
		//teraz znajdz mo|liwe wystpienia kilku najmniejszych takich samych liczb
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (tablicaArgumentow[i] == tablicaArgumentow[pozycja])
				cout << i + 1 << " "; //+ 1, bo tablica zaczyna sie od 0
		}
		cout << endl;
		delete[] tablicaArgumentow;
		return pozycja;
	}
	else {//je[li funkcja jaka[ podaBa ju| istniejc tablic

		int najmniejszaWartosc = 2147483647; //warto[ maksymalna dla int'a
		int pozycja = 0;

		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (wskaznikDoTablicy[i] < najmniejszaWartosc) {
				najmniejszaWartosc = wskaznikDoTablicy[i];
				pozycja = i;
			}
		}
		return pozycja;
	}
}

//posortuj tablice malejco
void f1(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];

	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);
	int pozycja = 0;

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		pozycja = f0(liczbaArgumentow - i, tablicaArgumentow);//podaj do f0 liczbaArgumentow - i, a na koncowkach 'tablicaArgumentow' dodawaj najmniejsze liczby

		ZamienMiejscami(tablicaArgumentow[liczbaArgumentow - i - 1], tablicaArgumentow[pozycja]);
	}

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;

}

//znajdz dBugo[ wektora
double f2(int liczbaArgumentow, double *wskaznikDoTablicy) {


	if (wskaznikDoTablicy == NULL) {
		double *tablicaArgumentow = new double[liczbaArgumentow];

		WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);


		double suma = 0;
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			suma += tablicaArgumentow[i] * tablicaArgumentow[i];
		}

		delete[] tablicaArgumentow;

		cout << Podloga(sqrt(suma)) << endl;
		return 0;
	}

	else {//je[li funkcja jaka[ podaBa ju| istniejc tablic
		double suma = 0;
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			suma += wskaznikDoTablicy[i] * wskaznikDoTablicy[i];
		}

		return sqrt(suma);
	}
}

//znajdz odchylenie standardowe
void f3(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	double sredniaLiczb = 0;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		sredniaLiczb += tablicaArgumentow[i];
	}
	sredniaLiczb = sredniaLiczb / liczbaArgumentow;

	//cout << "SREDNIA LICZB " << sredniaLiczb << endl;

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		tablicaArgumentow[i] -= sredniaLiczb;
		//cout << tablicaArgumentow[i] << " ";
	}
	double odchylenie = f2(liczbaArgumentow, tablicaArgumentow) / sqrt((double)liczbaArgumentow - 1);

	cout << Podloga(odchylenie) << endl;

	delete[] tablicaArgumentow;
}

//odwr� tablice w miejscu
void f4(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	for (int i = 0; i < liczbaArgumentow / 2; i++)
	{
		tablicaArgumentow[liczbaArgumentow - i - 1] += tablicaArgumentow[i];
		tablicaArgumentow[i] = tablicaArgumentow[liczbaArgumentow - i - 1] - tablicaArgumentow[i];
		tablicaArgumentow[liczbaArgumentow - i - 1] -= tablicaArgumentow[i];
	}
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;
}

//sprawdz czy liczby sa pierwsze
void f5(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	bool czyLiczbaJestPierwsza;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		czyLiczbaJestPierwsza = true;
		for (int j = 2; j <= Podloga(sqrt(tablicaArgumentow[i])); j++)
		{
			if ((int)Podloga(tablicaArgumentow[i]) % (j) == 0) {
				czyLiczbaJestPierwsza = false;
				break;
			}
		}
		//cout << czyLiczbaJestPierwsza;
		if (czyLiczbaJestPierwsza) {
			tablicaArgumentow[i] = 1;
		}
		else {
			tablicaArgumentow[i] = 0;
		}

		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;
}

void PosortujPunktyZadanie6(int liczbaArgumentow, double *tablicaArgumentow, double srodekX, double srodekY) {

	double *tablicaKatow = new double[liczbaArgumentow];

	//oblicz tangensa dla kazdego punktu xy
	for (int i = 0; i < liczbaArgumentow - 1; i += 2)//liczymy clockwise > v < ^
	{
		double deltaX = tablicaArgumentow[i] - srodekX;
		double deltaY = tablicaArgumentow[i + 1] - srodekY;

		tablicaKatow[i / 2] = (atan2(deltaY, deltaX) * 180 / M_PI); // tangens, konwersja na stopnie, tablica ta posiada polowe wielkosci 'tablicaArgumentow'
	}

	//posortowa teraz wg kt�w malejco

	for (int i = 0; i < liczbaArgumentow; i += 2)
	{
		int najmniejszaWartosc = 2147483647; //warto[ maksymalna dla int'a
		int pozycja = 0;

		for (int j = 0; j < (liczbaArgumentow - i) / 2; j++) // i/2 bo tablicaKatow jest 2 razy mniejsza
		{
			if (tablicaKatow[j] < najmniejszaWartosc) {
				najmniejszaWartosc = tablicaKatow[j];
				pozycja = j;
			}
		}

		ZamienMiejscami(tablicaKatow[((liczbaArgumentow - i) / 2) - 1], tablicaKatow[pozycja]);//kty

		ZamienMiejscami(tablicaArgumentow[liczbaArgumentow - 2 - i], tablicaArgumentow[pozycja * 2]);//wartosci x punkt�w
		ZamienMiejscami(tablicaArgumentow[liczbaArgumentow - 1 - i], tablicaArgumentow[pozycja * 2 + 1]);//wartosci y punkt�w
	}
}

//pole wielokta wypukBego
void f6(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	//oblicz punkt le|cy wewnatrz wielokta
	double srodekX = 0, srodekY = 0;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		if (i % 2 == 0) {
			srodekX += tablicaArgumentow[i];
		}
		else {
			srodekY += tablicaArgumentow[i];
		}
	}

	srodekX = srodekX / (liczbaArgumentow / 2);
	srodekY = srodekY / (liczbaArgumentow / 2);

	PosortujPunktyZadanie6(liczbaArgumentow, tablicaArgumentow, srodekX, srodekY);

	//policz pole tego wielokata
	int suma = 0;

	for (int i = 0; i < liczbaArgumentow - 3; i+=2)
	{
		suma += (tablicaArgumentow[i] * tablicaArgumentow[i + 3] - tablicaArgumentow[i + 1] * tablicaArgumentow[i + 2]);
	}

	suma += (tablicaArgumentow[liczbaArgumentow - 2] * tablicaArgumentow[1] - tablicaArgumentow[liczbaArgumentow - 1] * tablicaArgumentow[0]); //ostatni element sumy
	cout << abs(suma / 2) << endl;
	delete[] tablicaArgumentow;
}

//r�wnanie kwadratowe i sze[cienne
void f7(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	//r�wnanie kwadratowe
	if (tablicaArgumentow[0] == 0) {
		double a = tablicaArgumentow[1];
		double b = tablicaArgumentow[2];
		double c = tablicaArgumentow[3];

		double delta = b * b - 4 * a*c;

		if (delta >= 0) {
			double x1 = (-b - sqrt(delta)) / (2 * a);
			double x2 = (-b + sqrt(delta)) / (2 * a);

			if (x1 == x2) {
				cout << Podloga(x1) << endl;
			}
			else {
				if (x1 < x2) {
					cout << Podloga(x1) << " " << Podloga(x2) << endl;
				}
				else {
					cout << Podloga(x2) << " " << Podloga(x1) << endl;
				}
			}
		}
	}
	else {
		//r�wnanie sze[cienne
		double a = tablicaArgumentow[1]; // od drugiego elementu jest a
		double b = tablicaArgumentow[2];
		double c = tablicaArgumentow[3];

		double p = b - a * a / 3;
		double q = 2 * a*a*a / 27 - a * b / 3 + c;
		
		double delta = q * q / 4 + p * p*p / 27;

		if (Sufit(delta) > 0) {//jest tylko jedno rozwizanie
			
			double pomocnicza1 = -q / 2 + sqrt(delta);
			double pomocnicza2 = -q / 2 - sqrt(delta);
			double x = 0;

			if (pomocnicza1 < 0) {
				x += -pow(-pomocnicza1, 1.0 / 3.0);
			}
			else {
				x += pow(pomocnicza1, 1.0 / 3.0);
			}

			if (pomocnicza2 < 0) {
				x += -pow(-pomocnicza2, 1.0 / 3.0);
			}
			else {
				x += pow(pomocnicza2, 1.0 / 3.0);
			}

			x -= a / 3.0;
			cout << Podloga(x) << endl;
		}

		else if (Sufit(delta) == 0) { // dwa rozwizania		

			double x1 = 0, x2 = 0;
			if (q < 0) {
				x1 = -2 * (-pow(-q / 2.0, 1.0 / 3.0)) - a / 3.0;
				x2 = (-pow(-q / 2.0, 1.0 / 3.0)) - a / 3.0;
			}
			else {
				x1 = -2 * pow(q / 2.0, 1.0 / 3.0) - a / 3.0;
				x2 = pow(q / 2.0, 1.0 / 3.0) - a / 3.0;
			}

			cout << Podloga(x1) << " " << Podloga(x2) << endl;
		}
		else { // trzy rozwizania
			double x1 = 2 / sqrt(3.0)*sqrt(-p)*sin(1.0 / 3.0 * asin((3.0 * sqrt(3.0)*q) / (2.0 * sqrt(-p)*sqrt(-p)*sqrt(-p)))) - a/3.0;
			double x2 = 2 / sqrt(3.0)*sqrt(-p)*sin(1.0 / 3.0 * asin((3.0 * sqrt(3.0)*q) / (2.0 * sqrt(-p)*sqrt(-p)*sqrt(-p))) + M_PI / 3.0) - a / 3.0;
			double x3 = 2 / sqrt(3.0)*sqrt(-p)*sin(1.0 / 3.0 * acos((3.0 * sqrt(3.0)*q) / (2.0 * sqrt(-p)*sqrt(-p)*sqrt(-p))) + M_PI / 6.0) - a / 3.0;

			cout << Podloga(x1) << " " << Podloga(x2) << " " << Podloga(x3) << endl;
		}

	}

	delete[] tablicaArgumentow;
}

void f8(int liczbaArgumentow) {
	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	long long int wynik = 0;
	for (int i = 1; i <= tablicaArgumentow[0]; i++)
	{
		wynik += i * (i + 1)*(i + 1);
	}
	cout << fixed << wynik<< endl;
	delete[] tablicaArgumentow;
}

void f9(int liczbaArgumentow) {
	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDoTablicy(liczbaArgumentow, tablicaArgumentow);

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		uint32_t liczbaBitow = tablicaArgumentow[i];

		liczbaBitow = liczbaBitow - ((liczbaBitow >> 1) & 0x55555555);
		liczbaBitow = (liczbaBitow & 0x33333333) + ((liczbaBitow >> 2) & 0x33333333);
		liczbaBitow = (((liczbaBitow + (liczbaBitow >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;

		cout << liczbaBitow << " ";
	}
	cout << endl;
}

int main() {
	int subprogram, liczbaArgumentow;

	while (cin >> subprogram >> liczbaArgumentow) {
		switch (subprogram) {
		case 0:
			f0(liczbaArgumentow, NULL);
			break;
		case 1:
			f1(liczbaArgumentow);
			break;
		case 2:
			f2(liczbaArgumentow, NULL);
			break;
		case 3:
			f3(liczbaArgumentow);
			break;
		case 4:
			f4(liczbaArgumentow);
			break;
		case 5:
			f5(liczbaArgumentow);
			break;
		case 6:
			f6(liczbaArgumentow);
			break;
		case 7:
			f7(liczbaArgumentow);
			break;
		case 8:
			f8(liczbaArgumentow);
			break;
		case 9:
			f9(liczbaArgumentow);
			break;
		}
	};
	return 0;
}
