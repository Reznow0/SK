// SuperKalkulator.cpp : Ten plik zawiera funkcję „main”. W nim rozpoczyna się i kończy wykonywanie programu.
//

#include "pch.h"
#include <iostream>
#include <stdint.h>//uint32_t

using namespace std;

#define M_PI 3.141592653589793

void WczytajArgumentyDouble(int liczbaArgumentow, double *wskaznikDoTablicy) {

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cin >> wskaznikDoTablicy[i];
	}
}

void WczytajArgumentyInt(int liczbaArgumentow, int *wskaznikDoTablicy) {

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cin >> wskaznikDoTablicy[i];
	}
}

void WczytajArgumentyUint(int liczbaArgumentow, unsigned long long int *wskaznikDoTablicy) {

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cin >> wskaznikDoTablicy[i];
	}
}

void ZamienMiejscamiDouble(double &argument1, double &argument2) {

	double *x = &argument1;
	double *y = &argument2;


	if (*x != *y) { // zamiana bez użycia 3-ciej zmiennej
		*x += *y;
		*y = *x - *y;
		*x -= *y;
	}
}

void ZamienMiejscamiInt(int &argument1, int &argument2) {

	int *x = &argument1;
	int *y = &argument2;


	if (*x != *y) { // zamiana bez użycia 3-ciej zmiennej
		*x += *y;
		*y = *x - *y;
		*x -= *y;
	}
}

double Podloga(double y) {
	double x = ((__int64)(y * 1.0e+10)) / (1.0e+10);//zeruje wszystkie liczby po 10 miejscu po przecinku
	if (x >= 0) {
		return (int)x;
	}
	else {
		if ((int)x != x) {
			return (int)(x - 1);
		}
		else return x;
	}
}

double CubicRoot(double x) {
	if (x == 0) {
		return x;
	}
	else if (x > 0) {
		x = pow(x, 1.0 / 3.0);
		return x;
	}
	else {
		x = -pow(-x, 1.0 / 3.0);
		return x;
	}
}

//znajdź pozycje najmniejszej liczby
int f0(int liczbaArgumentow, int *wskaznikDoTablicy) {

	double najmniejszaWartosc = 2147483647; //wartość maksymalna dla int'a

	if (wskaznikDoTablicy == NULL) {
		int *tablicaArgumentow = new int[liczbaArgumentow];
		WczytajArgumentyInt(liczbaArgumentow, tablicaArgumentow);

		int pozycja = 0;

		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (tablicaArgumentow[i] < najmniejszaWartosc) {
				najmniejszaWartosc = tablicaArgumentow[i];
				pozycja = i;
			}
		}
		//teraz znajdz możliwe wystąpienia kilku najmniejszych takich samych liczb
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (tablicaArgumentow[i] == tablicaArgumentow[pozycja])
				cout << i + 1 << " "; //+ 1, bo tablica zaczyna sie od 0
		}
		cout << endl;
		delete[] tablicaArgumentow;
		return pozycja;
	}
	else {//jeśli funkcja jakaś podała już istniejącą tablicę

		int pozycja = 0;

		for (int i = 0; i < liczbaArgumentow; i++)
		{
			if (wskaznikDoTablicy[i] < najmniejszaWartosc) {
				najmniejszaWartosc = wskaznikDoTablicy[i];
				pozycja = i;
			}
		}
		return pozycja;
	}
}

//posortuj tablice malejąco
void f1(int liczbaArgumentow) {

	int *tablicaArgumentow = new int[liczbaArgumentow];

	WczytajArgumentyInt(liczbaArgumentow, tablicaArgumentow);
	int pozycja = 0;

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		pozycja = f0(liczbaArgumentow - i, tablicaArgumentow);//podaj do f0 liczbaArgumentow - i,a na koncowkach 'tablicaArgumentow' dodawaj najmniejsze liczby

		ZamienMiejscamiInt(tablicaArgumentow[liczbaArgumentow - i - 1], tablicaArgumentow[pozycja]);
	}

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;

}

//znajdz długość wektora
double f2(int liczbaArgumentow, double *wskaznikDoTablicy) {

	if (wskaznikDoTablicy == NULL) {
		int *tablicaArgumentow = new int[liczbaArgumentow];

		WczytajArgumentyInt(liczbaArgumentow, tablicaArgumentow);


		double suma = 0;
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			suma += tablicaArgumentow[i] * tablicaArgumentow[i];
		}

		delete[] tablicaArgumentow;

		cout << Podloga(sqrt(suma)) << endl;
		return 0;
	}

	else {//jeśli funkcja jakaś podała już istniejącą tablicę
		double suma = 0;
		for (int i = 0; i < liczbaArgumentow; i++)
		{
			suma += wskaznikDoTablicy[i] * wskaznikDoTablicy[i];
		}

		return suma;
	}
}

//znajdz odchylenie standardowe
void f3(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDouble(liczbaArgumentow, tablicaArgumentow);

	double sredniaLiczb = 0;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		sredniaLiczb += tablicaArgumentow[i];
	}
	sredniaLiczb /= liczbaArgumentow;

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		tablicaArgumentow[i] -= sredniaLiczb;
	}
	double odchylenie = sqrt(f2(liczbaArgumentow, tablicaArgumentow) / liczbaArgumentow);

	cout << Podloga(odchylenie) << endl;

	delete[] tablicaArgumentow;
}

//odwróć tablice w miejscu
void f4(int liczbaArgumentow) {

	int *tablicaArgumentow = new int[liczbaArgumentow];
	WczytajArgumentyInt(liczbaArgumentow, tablicaArgumentow);

	for (int i = 0; i < liczbaArgumentow / 2; i++)
	{
		ZamienMiejscamiInt(tablicaArgumentow[liczbaArgumentow - i - 1], tablicaArgumentow[i]);
	}
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;
}

//sprawdz czy liczby sa pierwsze
void f5(int liczbaArgumentow) {

	int *tablicaArgumentow = new int[liczbaArgumentow];
	WczytajArgumentyInt(liczbaArgumentow, tablicaArgumentow);

	bool czyLiczbaJestPierwsza;

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		czyLiczbaJestPierwsza = true;
		if (tablicaArgumentow[i] != 2 && tablicaArgumentow[i] % 2 == 0) {
			tablicaArgumentow[i] = 0;
		}
		else {
			for (int j = 3; j*j <= tablicaArgumentow[i]; j += 2)
			{
				if (tablicaArgumentow[i] % j == 0) {
					czyLiczbaJestPierwsza = false;
					break;
				}
			}

			if (czyLiczbaJestPierwsza) {
				tablicaArgumentow[i] = 1;
			}
			else {
				tablicaArgumentow[i] = 0;
			}
		}
		cout << tablicaArgumentow[i] << " ";
	}
	cout << endl;

	delete[] tablicaArgumentow;
}

void PosortujPunktyZadanie6(int liczbaArgumentow, double *tablicaArgumentow, double srodekX, double srodekY) {

	double *tablicaKatow = new double[liczbaArgumentow];

	//oblicz tangensa dla kazdego punktu xy
	for (int i = 0; i < liczbaArgumentow - 1; i += 2)//liczymy clockwise > v < ^
	{
		double deltaX = tablicaArgumentow[i] - srodekX;
		double deltaY = tablicaArgumentow[i + 1] - srodekY;

		tablicaKatow[i / 2] = (atan2(deltaY, deltaX) * 180 / M_PI); // tangens, konwersja na stopnie, tablica ta posiada polowe wielkosci 'tablicaArgumentow'
	}

	//posortować teraz wg kątów malejąco

	for (int i = 0; i < liczbaArgumentow; i += 2)
	{
		double najmniejszaWartosc = 2147483647; //wartość maksymalna dla int'a
		int pozycja = 0;

		for (int j = 0; j < (liczbaArgumentow - i) / 2; j++) // i/2 bo tablicaKatow jest 2 razy mniejsza
		{
			if (tablicaKatow[j] < najmniejszaWartosc) {
				najmniejszaWartosc = tablicaKatow[j];
				pozycja = j;
			}
		}

		ZamienMiejscamiDouble(tablicaKatow[((liczbaArgumentow - i) / 2) - 1], tablicaKatow[pozycja]);//kąty

		ZamienMiejscamiDouble(tablicaArgumentow[liczbaArgumentow - 2 - i], tablicaArgumentow[pozycja * 2]);//wartosci x punktów
		ZamienMiejscamiDouble(tablicaArgumentow[liczbaArgumentow - 1 - i], tablicaArgumentow[pozycja * 2 + 1]);//wartosci y punktów
	}
}

struct punkt {
	double x;
	double y;
} Punkt;

//pole wielokąta wypukłego
void f6(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDouble(liczbaArgumentow, tablicaArgumentow);

	//oblicz punkt leżący wewnatrz wielokąta
	double srodekX = 0, srodekY = 0;
	for (int i = 0; i < liczbaArgumentow; i++)
	{
		if (i % 2 == 0) {
			srodekX += tablicaArgumentow[i];
		}
		else {
			srodekY += tablicaArgumentow[i];
		}
	}

	srodekX = srodekX / (liczbaArgumentow / 2);
	srodekY = srodekY / (liczbaArgumentow / 2);

	PosortujPunktyZadanie6(liczbaArgumentow, tablicaArgumentow, srodekX, srodekY);

	//policz pole tego wielokata
	double suma = 0;

	for (int i = 0; i < liczbaArgumentow - 3; i += 2)
	{
		suma += (tablicaArgumentow[i] * tablicaArgumentow[i + 3] - tablicaArgumentow[i + 1] * tablicaArgumentow[i + 2]);
	}

	suma += (tablicaArgumentow[liczbaArgumentow - 2] * tablicaArgumentow[1] - tablicaArgumentow[liczbaArgumentow - 1] * tablicaArgumentow[0]); //ostatni element sumy
	cout << Podloga(abs(suma / 2.0)) << endl;

	delete[] tablicaArgumentow;
}

//równanie kwadratowe i sześcienne
void f7(int liczbaArgumentow) {

	double *tablicaArgumentow = new double[liczbaArgumentow];
	WczytajArgumentyDouble(liczbaArgumentow, tablicaArgumentow);

	//równanie kwadratowe
	if (tablicaArgumentow[0] == 0) {
		double a = tablicaArgumentow[1];
		double b = tablicaArgumentow[2];
		double c = tablicaArgumentow[3];

		double delta = b * b - 4 * a*c;

		if (delta == 0 && a != 0) {
			double x = (-b) / (2 * a);

			cout << Podloga(x) << endl;
		}
		else if (delta > 0) {
			double x1 = (-b - sqrt(delta)) / (2 * a);
			double x2 = (-b + sqrt(delta)) / (2 * a);

			if (x1 < x2) {//mniejszy pierwiastek wyswietl pierwszy
				cout << Podloga(x1) << " " << Podloga(x2) << endl;
			}
			else {
				cout << Podloga(x2) << " " << Podloga(x1) << endl;
			}

		}
		else
		{
			cout << endl;
		}
	}
	else {
		//równanie sześcienne
		double a = tablicaArgumentow[0];
		double b = tablicaArgumentow[1];
		double c = tablicaArgumentow[2];
		double d = tablicaArgumentow[3];

		double f = (((3 * c) / a) - (b*b) / (a*a)) / 3;
		double g = ((2 * b*b*b) / (a*a*a) - (9 * b*c) / (a*a) + (27 * d) / a) / 27;
		double h = (g*g) / 4 + (f*f*f) / 27;

		if (h > 0) {//jeden pierwiastek realny
			double R = sqrt(h) - g / 2;
			double S = CubicRoot(R);
			double T = -sqrt(h) - g / 2;
			double U = CubicRoot(T);

			double pierwiastek = (S + U) - b / (3 * a);
			cout << Podloga(pierwiastek) << endl;
		}

		else if (h == 0 && g == 0 && f == 0) {//1 pierwiastek potrójny
			double pierwiastek = -CubicRoot(d / a);
			cout << Podloga(pierwiastek) << endl;
		}
		else {//3 różne pierwiastki
			double i = sqrt((g*g) / 4 - h);
			double j = CubicRoot(i);
			double k = acos(-(g / (2 * i)));
			double L = -j;
			double M = cos(k / 3);
			double N = sqrt(3.0)*sin(k / 3);
			double P = -(b / (3 * a));

			double p1 = 2 * j*cos(k / 3) - (b / (3 * a));
			double p2 = L * (M + N) + P;
			double p3 = L * (M - N) + P;

			//sortuj
			if (p3 < p1) { ZamienMiejscamiDouble(p3, p1); }
			if (p2 < p1) { ZamienMiejscamiDouble(p2, p1); }

			//usuń duplikaty
			if (Podloga(p1) == Podloga(p2) && Podloga(p1) == Podloga(p3)) {
				cout << Podloga(p1) << endl;
			}
			else if (Podloga(p1) == Podloga(p2) || Podloga(p1) == Podloga(p3)) {
					cout << Podloga(p2) << " " << Podloga(p3) << endl;
			}
			else if (Podloga(p2) == Podloga(p1) || Podloga(p2) == Podloga(p3)) {
					cout << Podloga(p1) << " " << Podloga(p3) << endl;
			}
			else {
				cout << Podloga(p1) << " " << Podloga(p2) << " " << Podloga(p3) << endl;
			}
		}
	}

	delete[] tablicaArgumentow;
}

//oblicz wyrażenie dla zadanego n
void f8(int liczbaArgumentow) {
	int *tablicaArgumentow = new int[liczbaArgumentow];
	WczytajArgumentyInt(liczbaArgumentow, tablicaArgumentow);

	for (int i = 0; i < liczbaArgumentow; i++)
	{
		long long int wynik = 0;
		for (int j = 1; j <= tablicaArgumentow[i]; j++)
		{
			wynik += (j*j*j + 2 * j*j + j);
		}
		cout << fixed << wynik << " ";
	}
	cout << endl;
	delete[] tablicaArgumentow;
}

// zlicz liczbę bitów
void f9(int liczbaArgumentow) {
	unsigned long long int *tablicaArgumentow = new unsigned long long int[liczbaArgumentow];
	WczytajArgumentyUint(liczbaArgumentow, tablicaArgumentow);

	for (int i = 0; i < liczbaArgumentow; i++)//Brian Kernighan
	{
		unsigned long long int licznikBitow = 0;
		while (tablicaArgumentow[i]) {
			tablicaArgumentow[i] &= (tablicaArgumentow[i] - 1);
			licznikBitow++;
		}
		cout << licznikBitow << " ";
	}
	cout << endl;
}

int main() {
	int subprogram, liczbaArgumentow;
	while (cin >> subprogram >> liczbaArgumentow) {
		switch (subprogram) {
		case 0:
			f0(liczbaArgumentow, NULL);
			break;
		case 1:
			f1(liczbaArgumentow);
			break;
		case 2:
			f2(liczbaArgumentow, NULL);
			break;
		case 3:
			f3(liczbaArgumentow);
			break;
		case 4:
			f4(liczbaArgumentow);
			break;
		case 5:
			f5(liczbaArgumentow);
			break;
		case 6:
			f6(liczbaArgumentow);
			break;
		case 7:
			f7(liczbaArgumentow);
			break;
		case 8:
			f8(liczbaArgumentow);
			break;
		case 9:
			f9(liczbaArgumentow);
			break;
		}
	};
	return 0;
}
// Uruchomienie programu: Ctrl + F5 lub menu Debugowanie > Uruchom bez debugowania
// Debugowanie programu: F5 lub menu Debugowanie > Rozpocznij debugowanie

// Porady dotyczące rozpoczynania pracy:
//   1. Użyj okna Eksploratora rozwiązań, aby dodać pliki i zarządzać nimi
//   2. Użyj okna programu Team Explorer, aby nawiązać połączenie z kontrolą źródła
//   3. Użyj okna Dane wyjściowe, aby sprawdzić dane wyjściowe kompilacji i inne komunikaty
//   4. Użyj okna Lista błędów, aby zobaczyć błędy
//   5. Wybierz pozycję Projekt > Dodaj nowy element, aby utworzyć nowe pliki kodu, lub wybierz pozycję Projekt > Dodaj istniejący element, aby dodać istniejące pliku kodu do projektu
//   6. Aby w przyszłości ponownie otworzyć ten projekt, przejdź do pozycji Plik > Otwórz > Projekt i wybierz plik sln
